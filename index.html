<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>NoteCoco - Your Personal Organizer</title>
  <!-- Font Awesome for Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* Root Variables for Colors and Fonts */
    :root {
      --primary-color: #74acf2; /* Light Blue */
      --secondary-color: #0058a3; /* Dark Blue */
      --accent-color: #0058a3; /* Dark Blue */
      --text-color: #000000; /* Black Text */
      --background-color: #ffffff; /* White Background */
      --font-primary: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    /* Global Styles */
    body {
      margin: 0;
      font-family: var(--font-primary);
      background-color: var(--background-color);
      color: var(--text-color);
    }

    /* Header Styles */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: var(--primary-color);
      color: var(--accent-color);
      padding: 15px 30px;
      position: fixed;
      width: 100%;
      top: 0;
      z-index: 1000;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .logo {
      display: flex;
      align-items: center;
      cursor: default;
      font-size: 1.2rem;
      font-weight: bold;
    }

    .logo i {
      margin-right: 10px;
    }

    .header-right {
      position: relative;
    }

    .header-right i {
      margin-left: 20px;
      cursor: pointer;
      font-size: 1.2rem;
      transition: color 0.3s;
      position: relative;
    }

    .header-right i:hover {
      color: var(--secondary-color);
    }

    /* Notification Badge */
    .notification-badge {
      position: absolute;
      top: -5px;
      right: -10px;
      background-color: #f44336;
      color: white;
      padding: 2px 6px;
      border-radius: 50%;
      font-size: 0.75rem;
      display: none; /* Hidden by default */
    }

    /* Sidebar Styles */
    aside.sidebar {
      position: fixed;
      top: 60px; /* Height of the header */
      left: 0;
      width: 220px;
      height: calc(100% - 60px);
      background-color: #f9f9f9; /* Light Sidebar Background */
      box-shadow: 2px 0 5px rgba(0,0,0,0.1);
      overflow-y: auto;
      padding-bottom: 20px;
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background-color: var(--primary-color);
      color: var(--accent-color);
      border-bottom: 1px solid #ddd;
    }

    .sidebar-header h2 {
      margin: 0;
      font-size: 1.1rem;
    }

    .sidebar-menu .menu-item {
      display: flex;
      align-items: center;
      padding: 12px 20px;
      cursor: pointer;
      transition: background 0.2s;
      border-bottom: 1px solid #ddd;
      position: relative;
      color: var(--text-color);
    }

    .sidebar-menu .menu-item:hover,
    .sidebar-menu .menu-item.active {
      background-color: var(--secondary-color);
      color: var(--background-color);
    }

    .sidebar-menu .menu-item i {
      margin-right: 12px;
      color: var(--secondary-color);
      min-width: 20px;
      text-align: center;
    }

    /* Main Content Styles */
    main {
      margin-left: 220px; /* Width of the sidebar */
      padding: 80px 40px 40px 40px; /* Top padding accounts for fixed header */
      transition: margin-left 0.3s ease;
    }

    /* Kanban Board Styles */
    .kanban-board {
      display: flex;
      gap: 30px;
      flex-wrap: wrap;
      justify-content: flex-start;
    }

    .kanban-column {
      background-color: #f9f9f9; /* Light Column Background */
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
      flex: 1;
      min-width: 300px;
      max-width: 100%;
      display: flex;
      flex-direction: column;
      max-height: 80vh;
      overflow-y: auto;
    }

    .kanban-column h3 {
      margin-top: 0;
      display: flex;
      align-items: center;
      font-size: 1.3rem;
      color: var(--primary-color);
      margin-bottom: 15px;
    }

    .kanban-column h3 i {
      margin-right: 10px;
    }

    .cards-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .card {
      background-color: #ffffff; /* White Card Background */
      padding: 15px;
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      position: relative;
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
      display: flex;
      flex-direction: column;
    }

    .card:hover {
      background-color: #f0f0f0;
      transform: translateY(-2px);
    }

    /* Adjusted Card Header to Prevent Overlapping */
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
    }

    .card-header-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .card-header-left i {
      font-size: 1rem;
      color: var(--primary-color);
    }

    .card-header .title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-color);
    }

    .card-header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .card-header .favorite-btn {
      background: none;
      border: none;
      cursor: pointer;
      color: #ff9800;
      font-size: 1rem;
      transition: color 0.3s;
    }

    .card-header .favorite-btn:hover {
      color: #e68900;
    }

    .card-actions button {
      background: none;
      border: none;
      cursor: pointer;
      color: #555;
      font-size: 0.9rem;
      transition: color 0.3s;
    }

    .card-actions button:hover {
      color: var(--primary-color);
    }

    .details {
      margin-top: 10px;
      font-size: 0.9rem;
      color: #555;
    }

    .attachments img {
      max-width: 100px;
      max-height: 100px;
      margin-right: 8px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }

    .attachments a {
      display: inline-block;
      margin-top: 8px;
      color: var(--primary-color);
      text-decoration: none;
      font-size: 0.9rem;
    }

    .attachments a:hover {
      text-decoration: underline;
    }

    /* Form Elements */
    input[type="text"],
    textarea,
    select,
    input[type="date"] {
      width: 100%;
      padding: 10px 12px;
      margin-top: 6px;
      margin-bottom: 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
      font-size: 0.95rem;
      background-color: #ffffff;
      color: var(--text-color);
    }

    textarea {
      resize: vertical;
      min-height: 200px; /* Minimum height as per requirement */
      height: auto;
      overflow: auto;
    }

    label {
      font-weight: 500;
      color: var(--text-color);
    }

    .multi-select {
      display: flex;
      flex-wrap: wrap;
      gap: 10px; /* Space between tags */
      margin-top: 6px;
      margin-bottom: 12px;
    }

    /* Individual Tag Labels */
    .multi-select label {
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 5px 10px;
      cursor: pointer;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      transition: background-color 0.2s, border-color 0.2s;
    }

    .multi-select label:hover {
      background-color: #e0e0e0;
      border-color: #bbb;
    }

    .multi-select label input {
      margin-right: 6px;
      cursor: pointer;
    }

    /* New Tags Input */
    #note-new-tags,
    #edit-note-new-tags {
      width: 100%;
      padding: 8px 10px;
      margin-top: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background-color: #ffffff;
      color: var(--text-color);
      font-size: 0.95rem;
    }

    /* Recurrence Options */
    .recurrence-options label {
      display: inline-block;
      margin-right: 15px;
      font-weight: normal;
      color: #555;
    }

    .custom-days {
      display: flex;
      gap: 10px;
      margin-top: 6px;
      margin-bottom: 12px;
    }

    .custom-days label {
      display: flex;
      align-items: center;
      gap: 4px;
      font-weight: normal;
      color: #555;
    }

    /* Buttons */
    .btn {
      background-color: var(--secondary-color);
      color: var(--background-color);
      border: none;
      padding: 10px 16px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.95rem;
      transition: background 0.3s;
      align-self: flex-start;
    }

    .btn:hover {
      background-color: #004a80;
    }

    /* Notification Styles */
    .notification {
      position: fixed;
      top: 80px;
      right: 30px;
      background-color: #333;
      color: #fff;
      padding: 12px 20px;
      border-radius: 5px;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 1001;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }

    .notification.show {
      opacity: 1;
    }

    .notification.success {
      background-color: #4CAF50;
    }

    .notification.error {
      background-color: #f44336;
    }

    /* Footer Styles */
    footer {
      text-align: center;
      padding: 15px;
      font-size: 0.85rem;
      color: #777;
      position: fixed;
      bottom: 0;
      width: 100%;
      background-color: #f9f9f9;
      box-shadow: 0 -1px 5px rgba(0,0,0,0.1);
    }

    /* Responsive Design */
    @media (max-width: 1200px) {
      .kanban-board {
        justify-content: center;
      }
    }

    @media (max-width: 768px) {
      main {
        padding: 80px 20px 60px 240px;
      }
      header {
        padding: 15px 20px;
      }
      .sidebar-header {
        display: none;
      }
      .sidebar-menu .menu-item {
        padding: 12px 15px;
      }
    }

    /* Search Modal Styles */
    .search-modal {
      display: none; /* Hidden by default */
      position: fixed; /* Stay in place */
      z-index: 1500; /* Sit on top */
      left: 0;
      top: 0;
      width: 100%; /* Full width */
      height: 100%; /* Full height */
      overflow: auto; /* Enable scroll if needed */
      background-color: rgba(0,0,0,0.8); /* Black w/ opacity */
    }

    .search-modal-content {
      background-color: #ffffff;
      margin: 10% auto; /* 10% from the top and centered */
      padding: 20px;
      border: 1px solid #ccc;
      width: 80%; /* Could be more or less, depending on screen size */
      max-width: 600px;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    .close {
      color: #555;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .close:hover,
    .close:focus {
      color: var(--primary-color);
      text-decoration: none;
    }

    #search-input {
      width: 100%;
      padding: 12px 20px;
      margin: 12px 0 20px 0;
      box-sizing: border-box;
      border: 2px solid #ccc;
      border-radius: 4px;
      font-size: 1rem;
      background-color: #ffffff;
      color: var(--text-color);
    }

    #search-results {
      max-height: 400px;
      overflow-y: auto;
      color: var(--text-color);
    }

    .search-category {
      margin-bottom: 20px;
    }

    .search-category h4 {
      margin-bottom: 10px;
      color: var(--primary-color);
    }

    .search-item {
      padding: 10px;
      border-bottom: 1px solid #ddd;
      cursor: pointer;
      transition: background 0.2s;
    }

    .search-item:hover {
      background-color: #f0f0f0;
    }

    .highlight {
      background-color: #ffd700; /* Gold */
      color: #000;
    }

    /* Notifications Modal Styles */
    .notifications-modal {
      display: none; /* Hidden by default */
      position: fixed; /* Stay in place */
      z-index: 1600; /* Sit on top of other modals */
      left: 0;
      top: 0;
      width: 100%; /* Full width */
      height: 100%; /* Full height */
      overflow: auto; /* Enable scroll if needed */
      background-color: rgba(0,0,0,0.8); /* Black w/ opacity */
    }

    .notifications-modal-content {
      background-color: #ffffff;
      margin: 5% auto; /* 5% from the top and centered */
      padding: 20px;
      border: 1px solid #ccc;
      width: 90%; /* Could be more or less, depending on screen size */
      max-width: 600px;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    .notifications-modal-content h2 {
      margin-top: 0;
      color: var(--primary-color);
    }

    .notifications-modal-content .close {
      color: #555;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .notifications-modal-content .close:hover,
    .notifications-modal-content .close:focus {
      color: var(--primary-color);
      text-decoration: none;
    }

    .notification-item {
      padding: 10px;
      border-bottom: 1px solid #ddd;
      color: var(--text-color);
      background-color: #f9f9f9;
      border-radius: 4px;
      margin-bottom: 10px;
    }

    .notification-item p {
      margin: 0;
      font-size: 0.95rem;
    }

    .notification-item small {
      color: #777;
    }

    .notification-item button {
      margin-top: 5px;
      background-color: var(--secondary-color);
      color: var(--background-color);
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
      transition: background 0.3s;
    }

    .notification-item button:hover {
      background-color: #004a80;
    }

    /* Edit Modals Styles */
    .edit-modal {
      display: none; /* Hidden by default */
      position: fixed; /* Stay in place */
      z-index: 1700; /* Sit on top of other modals */
      left: 0;
      top: 0;
      width: 100%; /* Full width */
      height: 100%; /* Full height */
      overflow: auto; /* Enable scroll if needed */
      background-color: rgba(0,0,0,0.8); /* Black w/ opacity */
    }

    .edit-modal-content {
      background-color: #ffffff;
      margin: 5% auto; /* 5% from the top and centered */
      padding: 20px;
      border: 1px solid #ccc;
      width: 90%; /* Could be more or less, depending on screen size */
      max-width: 600px;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    .edit-modal-content h2 {
      margin-top: 0;
      color: var(--primary-color);
    }

    .edit-modal-content .close {
      color: #555;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .edit-modal-content .close:hover,
    .edit-modal-content .close:focus {
      color: var(--primary-color);
      text-decoration: none;
    }

    .edit-modal-content form {
      display: flex;
      flex-direction: column;
    }

    .edit-modal-content label {
      margin-top: 10px;
      font-weight: 500;
      color: var(--text-color);
    }

    .edit-modal-content .form-group {
      margin-top: 10px;
    }

    .edit-modal-content .form-group input,
    .edit-modal-content .form-group textarea,
    .edit-modal-content .form-group select {
      width: 100%;
      padding: 8px 10px;
      margin-top: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background-color: #ffffff;
      color: var(--text-color);
    }

    .edit-modal-content .recurrence-options label {
      display: inline-block;
      margin-right: 15px;
      font-weight: normal;
      color: #555;
    }

    .edit-modal-content .custom-days {
      display: flex;
      gap: 10px;
      margin-top: 6px;
      margin-bottom: 12px;
    }

    .edit-modal-content .custom-days label {
      display: flex;
      align-items: center;
      gap: 4px;
      font-weight: normal;
      color: #555;
    }

    .edit-modal-content .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .edit-modal-content .btn-group .btn {
      flex: 1;
    }

    /* Nested Notes Container */
    .nested-notes {
      display: grid;
      grid-template-columns: repeat(auto-fill, 120px);
      grid-gap: 20px; /* 20px gap between cards */
      padding-left: 20px;
      border-left: 2px solid #ddd;
      margin-top: 10px;
      
      /* Prevent Horizontal Scrolling */
      overflow-x: hidden;
    }

    /* Note Card Styles */
    .nested-note-card {
      width: 120px; /* Fixed width */
      height: 160px; /* Fixed height */
      background-color: #ffffff;
      border-radius: 4px;
      padding: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
      
      /* Prevent Flexbox properties from interfering */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: flex-start;
      
      /* Optional: Add padding for better content spacing */
      padding: 5px;
      
      /* Text Overflow Handling */
      overflow: hidden;
    }

    /* Hover Effect for Note Cards */
    .nested-note-card:hover {
      background-color: #f0f0f0;
      transform: translateY(-2px);
    }

    /* Note Title */
    .nested-note-title {
      font-size: 0.85rem;
      font-weight: bold;
      color: var(--text-color);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Note Snippet */
    .nested-note-snippet {
      font-size: 0.75rem;
      color: #555;
      margin-top: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Expand/Collapse Icon */
    .expand-icon {
      margin-left: auto;
      transition: transform 0.3s;
    }

    .expand-icon.expanded {
      transform: rotate(90deg);
    }

    /* Responsive Adjustments */
    @media (max-width: 1300px) {
      .nested-notes {
        grid-template-columns: repeat(auto-fill, 120px);
      }
    }

    @media (max-width: 800px) {
      .nested-notes {
        grid-template-columns: repeat(auto-fill, 120px);
        grid-gap: 15px; /* Slightly smaller gaps on smaller screens */
      }
    }

    @media (max-width: 500px) {
      .nested-notes {
        grid-template-columns: repeat(auto-fill, 120px);
        grid-gap: 10px; /* Even smaller gaps */
      }
    }

    /* Existing Styles... */
  </style>
</head>
<body>
  
  <!-- Header -->
  <header>
    <div class="logo">
      <i class="fas fa-feather-alt"></i>
      <span>NoteCoco</span>
    </div>
    <div class="header-right">
      <i class="fas fa-search" title="Search" onclick="openSearch()"></i>
      <i class="fas fa-bell" title="Notifications" onclick="openNotifications()">
        <span class="notification-badge" id="notification-badge">0</span>
      </i>
      <i class="fas fa-user-circle" title="Profile" onclick="showProfile()"></i>
    </div>
  </header>
  
  <!-- Sidebar -->
  <aside class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <h2>Menu</h2>
      <!-- Removed toggle button -->
    </div>
    <div class="sidebar-menu">
      <div class="menu-item active" onclick="navigate('dashboard')">
        <i class="fas fa-tachometer-alt"></i>
        <span>Dashboard</span>
      </div>
      <div class="menu-item" onclick="navigate('notebooks')">
        <i class="fas fa-book"></i>
        <span>Notebooks</span>
      </div>
      <div class="menu-item" onclick="navigate('tags')">
        <i class="fas fa-tags"></i>
        <span>Tags</span>
      </div>
      <div class="menu-item" onclick="navigate('notes')">
        <i class="fas fa-sticky-note"></i>
        <span>Notes</span>
      </div>
      <div class="menu-item" onclick="navigate('tasks')">
        <i class="fas fa-tasks"></i>
        <span>Tasks</span>
      </div>
      <div class="menu-item" onclick="navigate('habits')">
        <i class="fas fa-heartbeat"></i>
        <span>Habits</span>
      </div>
      <!-- New Trash Menu Item -->
      <div class="menu-item" onclick="navigate('trash')">
        <i class="fas fa-trash"></i>
        <span>Trash</span>
      </div>
      <!-- Removed Favorites Menu Item -->
    </div>
  </aside>
  
  <!-- Main Content -->
  <main>
    <!-- Kanban Board -->
    <div class="kanban-board">
      
      <!-- Dashboard -->
      <section class="kanban-column" id="dashboard-section">
        <h3><i class="fas fa-tachometer-alt"></i> Dashboard</h3>
        <p>Welcome to NoteCoco! Manage your notes, tasks, and habits efficiently.</p>
        
        <!-- Favorites Section on Dashboard -->
        <div class="favorites-section">
          <h4><i class="fas fa-star"></i> Favorites</h4>
          
          <!-- Favorite Notebooks -->
          <div class="favorites-subsection" id="favorite-notebooks">
            <h5><i class="fas fa-book"></i> Notebooks</h5>
            <div class="favorites-list" id="favorites-dashboard-notebooks-list">
              <!-- Favorite Notebooks will be rendered here -->
            </div>
          </div>
          
          <!-- Favorite Tags -->
          <div class="favorites-subsection" id="favorite-tags">
            <h5><i class="fas fa-tags"></i> Tags</h5>
            <div class="favorites-list" id="favorites-dashboard-tags-list">
              <!-- Favorite Tags will be rendered here -->
            </div>
          </div>
          
          <!-- Favorite Notes -->
          <div class="favorites-subsection" id="favorite-notes">
            <h5><i class="fas fa-sticky-note"></i> Notes</h5>
            <div class="favorites-list" id="favorites-dashboard-notes-list">
              <!-- Favorite Notes will be rendered here -->
            </div>
          </div>
          
          <!-- Favorite Tasks -->
          <div class="favorites-subsection" id="favorite-tasks">
            <h5><i class="fas fa-tasks"></i> Tasks</h5>
            <div class="favorites-list" id="favorites-dashboard-tasks-list">
              <!-- Favorite Tasks will be rendered here -->
            </div>
          </div>
          
          <!-- Favorite Habits -->
          <div class="favorites-subsection" id="favorite-habits">
            <h5><i class="fas fa-heartbeat"></i> Habits</h5>
            <div class="favorites-list" id="favorites-dashboard-habits-list">
              <!-- Favorite Habits will be rendered here -->
            </div>
          </div>
        </div>
      </section>
      
      <!-- Notebooks -->
      <section class="kanban-column" id="notebooks-section" style="display: none;">
        <h3><i class="fas fa-book"></i> Notebooks</h3>
        <p>Create and organize your notebooks.</p>
        <input type="text" id="new-notebook-input" placeholder="Enter notebook name..." />
        <button class="btn" onclick="addNotebook()">Add Notebook</button>
        <div class="cards-list" id="notebooks-list">
          <!-- Notebooks will be rendered as cards here -->
        </div>
      </section>
      
      <!-- Tags -->
      <section class="kanban-column" id="tags-section" style="display: none;">
        <h3><i class="fas fa-tags"></i> Tags</h3>
        <p>Create and manage tags for better organization.</p>
        <input type="text" id="new-tag-input" placeholder="Enter tag name..." />
        <button class="btn" onclick="addTag()">Add Tag</button>
        <div class="cards-list" id="tags-list">
          <!-- Tags will be rendered as cards here -->
        </div>
      </section>
      
      <!-- Notes -->
      <section class="kanban-column" id="notes-section" style="display: none;">
        <h3><i class="fas fa-sticky-note"></i> Notes</h3>
        <p>Create and manage your notes.</p>
        <input type="text" id="note-title" placeholder="Note Title..." />
        <textarea id="note-body" rows="3" placeholder="Note Body..."></textarea>
        
        <label><strong>Tags:</strong></label>
        <div id="note-tags" class="multi-select"></div>
        <input type="text" id="note-new-tags" placeholder="Add new tags (comma separated)" />
        
        <label><strong>Notebook:</strong></label>
        <select id="note-notebook-select">
          <option value="">No Notebook</option>
        </select>
        
        <label><strong>Attachments:</strong></label>
        <input type="file" id="note-attachments" multiple accept="image/*,application/pdf,.doc,.docx,.txt" />
        <small>Max size: 2MB. Supported: Images, PDF, DOC, DOCX, TXT.</small>
        
        <button class="btn" onclick="addNote()">Add Note</button>
        <div class="cards-list" id="notes-list">
          <!-- Notes will be rendered as cards here -->
        </div>
      </section>
      
      <!-- Tasks -->
      <section class="kanban-column" id="tasks-section" style="display: none;">
        <h3><i class="fas fa-tasks"></i> Tasks</h3>
        <p>Create and manage your tasks with due dates and recurrence.</p>
        <input type="text" id="task-input" placeholder="Enter task description..." />
        <input type="date" id="task-due-date" />
        
        <label><strong>Recurrence:</strong></label>
        <div class="recurrence-options">
          <label><input type="radio" name="task-recurrence" value="none" checked onclick="toggleTaskCustomDays(false)"> None</label>
          <label><input type="radio" name="task-recurrence" value="daily" onclick="toggleTaskCustomDays(false)"> Daily</label>
          <label><input type="radio" name="task-recurrence" value="weekly" onclick="toggleTaskCustomDays(false)"> Weekly</label>
          <label><input type="radio" name="task-recurrence" value="monthly" onclick="toggleTaskCustomDays(false)"> Monthly</label>
          <label><input type="radio" name="task-recurrence" value="custom" onclick="toggleTaskCustomDays(true)"> Custom Days</label>
        </div>
        
        <div id="task-custom-days" class="custom-days" style="display: none;">
          <label><input type="checkbox" value="Monday"> M</label>
          <label><input type="checkbox" value="Tuesday"> T</label>
          <label><input type="checkbox" value="Wednesday"> W</label>
          <label><input type="checkbox" value="Thursday"> T</label>
          <label><input type="checkbox" value="Friday"> F</label>
          <label><input type="checkbox" value="Saturday"> S</label>
          <label><input type="checkbox" value="Sunday"> S</label>
        </div>
        
        <button class="btn" onclick="addTask()">Add Task</button>
        <div class="cards-list" id="tasks-list">
          <!-- Tasks will be rendered as cards here -->
        </div>
      </section>
      
      <!-- Habits -->
      <section class="kanban-column" id="habits-section" style="display: none;">
        <h3><i class="fas fa-heartbeat"></i> Habits</h3>
        <p>Create and track your habits.</p>
        <input type="text" id="habit-input" placeholder="Enter habit description..." />
        
        <label><strong>Recurrence:</strong></label>
        <div class="recurrence-options">
          <label><input type="radio" name="habit-recurrence" value="none" checked onclick="toggleHabitCustomDays(false)"> None</label>
          <label><input type="radio" name="habit-recurrence" value="daily" onclick="toggleHabitCustomDays(false)"> Daily</label>
          <label><input type="radio" name="habit-recurrence" value="weekly" onclick="toggleHabitCustomDays(false)"> Weekly</label>
          <label><input type="radio" name="habit-recurrence" value="monthly" onclick="toggleHabitCustomDays(false)"> Monthly</label>
          <label><input type="radio" name="habit-recurrence" value="custom" onclick="toggleHabitCustomDays(true)"> Custom Days</label>
        </div>
        
        <div id="habit-custom-days" class="custom-days" style="display: none;">
          <label><input type="checkbox" value="Monday"> M</label>
          <label><input type="checkbox" value="Tuesday"> T</label>
          <label><input type="checkbox" value="Wednesday"> W</label>
          <label><input type="checkbox" value="Thursday"> T</label>
          <label><input type="checkbox" value="Friday"> F</label>
          <label><input type="checkbox" value="Saturday"> S</label>
          <label><input type="checkbox" value="Sunday"> S</label>
        </div>
        
        <button class="btn" onclick="addHabit()">Add Habit</button>
        <div class="cards-list" id="habits-list">
          <!-- Habits will be rendered as cards here -->
        </div>
      </section>
      
      <!-- Trash -->
      <section class="kanban-column" id="trash-section" style="display: none;">
        <h3><i class="fas fa-trash"></i> Trash</h3>
        <p>Manage your deleted notes here.</p>
        <div class="cards-list" id="trash-list">
          <!-- Trashed notes will be rendered as cards here -->
        </div>
      </section>
      
      <!-- Removed Separate Favorites Section -->
      
    </div>
  </main>
  
  <!-- Search Modal -->
  <div id="search-modal" class="search-modal">
    <div class="search-modal-content">
      <span class="close" onclick="closeSearch()">&times;</span>
      <h2>Search NoteCoco</h2>
      <input type="text" id="search-input" placeholder="Type to search..." oninput="performSearch()" />
      <div id="search-results">
        <!-- Search results will be dynamically inserted here -->
      </div>
    </div>
  </div>
  
  <!-- Notifications Modal -->
  <div id="notifications-modal" class="notifications-modal">
    <div class="notifications-modal-content">
      <span class="close" onclick="closeNotifications()">&times;</span>
      <h2>Notifications</h2>
      <div id="notifications-list">
        <!-- Notifications will be dynamically inserted here -->
      </div>
    </div>
  </div>
  
  <!-- Edit Notebook Modal -->
  <div id="edit-notebook-modal" class="edit-modal">
    <div class="edit-modal-content">
      <span class="close" onclick="closeEditModal('notebook')">&times;</span>
      <h2>Edit Notebook</h2>
      <form id="edit-notebook-form">
        <div class="form-group">
          <label for="edit-notebook-name">Name:</label>
          <input type="text" id="edit-notebook-name" required />
        </div>
        <div class="btn-group">
          <button type="submit" class="btn">Save</button>
          <button type="button" class="btn" onclick="closeEditModal('notebook')">Cancel</button>
        </div>
      </form>
    </div>
  </div>
  
  <!-- Edit Tag Modal -->
  <div id="edit-tag-modal" class="edit-modal">
    <div class="edit-modal-content">
      <span class="close" onclick="closeEditModal('tag')">&times;</span>
      <h2>Edit Tag</h2>
      <form id="edit-tag-form">
        <div class="form-group">
          <label for="edit-tag-name">Name:</label>
          <input type="text" id="edit-tag-name" required />
        </div>
        <div class="btn-group">
          <button type="submit" class="btn">Save</button>
          <button type="button" class="btn" onclick="closeEditModal('tag')">Cancel</button>
        </div>
      </form>
    </div>
  </div>
  
  <!-- Edit Note Modal -->
  <div id="edit-note-modal" class="edit-modal">
    <div class="edit-modal-content">
      <span class="close" onclick="closeEditModal('note')">&times;</span>
      <h2>Edit Note</h2>
      <form id="edit-note-form">
        <div class="form-group">
          <label for="edit-note-title">Title:</label>
          <input type="text" id="edit-note-title" required />
        </div>
        <div class="form-group">
          <label for="edit-note-body">Body:</label>
          <textarea id="edit-note-body" rows="4" required></textarea>
        </div>
        <div class="form-group">
          <label><strong>Tags:</strong></label>
          <div id="edit-note-tags" class="multi-select"></div>
          <input type="text" id="edit-note-new-tags" placeholder="Add new tags (comma separated)" />
        </div>
        <div class="form-group">
          <label for="edit-note-notebook">Notebook:</label>
          <select id="edit-note-notebook">
            <option value="">No Notebook</option>
          </select>
        </div>
        <div class="form-group">
          <label><strong>Attachments:</strong></label>
          <input type="file" id="edit-note-attachments" multiple accept="image/*,application/pdf,.doc,.docx,.txt" />
          <small>Max size: 2MB. Supported: Images, PDF, DOC, DOCX, TXT.</small>
        </div>
        <div class="btn-group">
          <button type="submit" class="btn">Save</button>
          <button type="button" class="btn" onclick="closeEditModal('note')">Cancel</button>
        </div>
      </form>
    </div>
  </div>
  
  <!-- Edit Task Modal -->
  <div id="edit-task-modal" class="edit-modal">
    <div class="edit-modal-content">
      <span class="close" onclick="closeEditModal('task')">&times;</span>
      <h2>Edit Task</h2>
      <form id="edit-task-form">
        <div class="form-group">
          <label for="edit-task-description">Description:</label>
          <input type="text" id="edit-task-description" required />
        </div>
        <div class="form-group">
          <label for="edit-task-due-date">Due Date:</label>
          <input type="date" id="edit-task-due-date" />
        </div>
        <div class="form-group">
          <label><strong>Recurrence:</strong></label>
          <div class="recurrence-options">
            <label><input type="radio" name="edit-task-recurrence" value="none" checked onclick="toggleEditTaskCustomDays(false)"> None</label>
            <label><input type="radio" name="edit-task-recurrence" value="daily" onclick="toggleEditTaskCustomDays(false)"> Daily</label>
            <label><input type="radio" name="edit-task-recurrence" value="weekly" onclick="toggleEditTaskCustomDays(false)"> Weekly</label>
            <label><input type="radio" name="edit-task-recurrence" value="monthly" onclick="toggleEditTaskCustomDays(false)"> Monthly</label>
            <label><input type="radio" name="edit-task-recurrence" value="custom" onclick="toggleEditTaskCustomDays(true)"> Custom Days</label>
          </div>
        </div>
        <div id="edit-task-custom-days" class="custom-days" style="display: none;">
          <label><input type="checkbox" value="Monday"> M</label>
          <label><input type="checkbox" value="Tuesday"> T</label>
          <label><input type="checkbox" value="Wednesday"> W</label>
          <label><input type="checkbox" value="Thursday"> T</label>
          <label><input type="checkbox" value="Friday"> F</label>
          <label><input type="checkbox" value="Saturday"> S</label>
          <label><input type="checkbox" value="Sunday"> S</label>
        </div>
        <div class="btn-group">
          <button type="submit" class="btn">Save</button>
          <button type="button" class="btn" onclick="closeEditModal('task')">Cancel</button>
        </div>
      </form>
    </div>
  </div>
  
  <!-- Edit Habit Modal -->
  <div id="edit-habit-modal" class="edit-modal">
    <div class="edit-modal-content">
      <span class="close" onclick="closeEditModal('habit')">&times;</span>
      <h2>Edit Habit</h2>
      <form id="edit-habit-form">
        <div class="form-group">
          <label for="edit-habit-description">Description:</label>
          <input type="text" id="edit-habit-description" required />
        </div>
        <div class="form-group">
          <label><strong>Recurrence:</strong></label>
          <div class="recurrence-options">
            <label><input type="radio" name="edit-habit-recurrence" value="none" checked onclick="toggleEditHabitCustomDays(false)"> None</label>
            <label><input type="radio" name="edit-habit-recurrence" value="daily" onclick="toggleEditHabitCustomDays(false)"> Daily</label>
            <label><input type="radio" name="edit-habit-recurrence" value="weekly" onclick="toggleEditHabitCustomDays(false)"> Weekly</label>
            <label><input type="radio" name="edit-habit-recurrence" value="monthly" onclick="toggleEditHabitCustomDays(false)"> Monthly</label>
            <label><input type="radio" name="edit-habit-recurrence" value="custom" onclick="toggleEditHabitCustomDays(true)"> Custom Days</label>
          </div>
        </div>
        <div id="edit-habit-custom-days" class="custom-days" style="display: none;">
          <label><input type="checkbox" value="Monday"> M</label>
          <label><input type="checkbox" value="Tuesday"> T</label>
          <label><input type="checkbox" value="Wednesday"> W</label>
          <label><input type="checkbox" value="Thursday"> T</label>
          <label><input type="checkbox" value="Friday"> F</label>
          <label><input type="checkbox" value="Saturday"> S</label>
          <label><input type="checkbox" value="Sunday"> S</label>
        </div>
        <div class="btn-group">
          <button type="submit" class="btn">Save</button>
          <button type="button" class="btn" onclick="closeEditModal('habit')">Cancel</button>
        </div>
      </form>
    </div>
  </div>
  
  <!-- Notification -->
  <div class="notification" id="notification"></div>
  
  <!-- Footer -->
  <footer>
    &copy; 2024-2025 NoteCoco. <a href="https://buymeacoffee.com/mpalmero" target="_blank"><i class="fas fa-coffee"></i> Buy me a coffee?</a> All rights reserved.
  </footer>
  
  <!-- JavaScript -->
  <script>
    // Helper Function to Retrieve CSS Variables
    function getCSSVariable(variableName) {
      return getComputedStyle(document.documentElement).getPropertyValue(variableName).trim();
    }

    // Data Structures
    let notebooks = [];
    let tags = [];
    let notes = [];
    let tasks = [];
    let habits = [];
    let notifications = []; // New array for notifications
    let trashedNotes = []; // New array for trashed notes

    // Initialize Application
    window.onload = function() {
      loadData();
      ensurePersonalNotebook();
      populateNotebookSelect();
      populateTagSelectors();
      renderAll();
      resetStreaks();
      initializeNotifications(); // Initialize notification badge
      checkUpcomingEvents(); // Check for upcoming events
    };

    // Load Data from localStorage
    function loadData() {
      try {
        notebooks = JSON.parse(localStorage.getItem('notecoco_notebooks')) || [];
      } catch (e) {
        console.error('Error parsing notebooks:', e);
        notebooks = [];
      }

      try {
        tags = JSON.parse(localStorage.getItem('notecoco_tags')) || [];
      } catch (e) {
        console.error('Error parsing tags:', e);
        tags = [];
      }

      try {
        notes = JSON.parse(localStorage.getItem('notecoco_notes')) || [];
      } catch (e) {
        console.error('Error parsing notes:', e);
        notes = [];
      }

      try {
        tasks = JSON.parse(localStorage.getItem('notecoco_tasks')) || [];
      } catch (e) {
        console.error('Error parsing tasks:', e);
        tasks = [];
      }

      try {
        habits = JSON.parse(localStorage.getItem('notecoco_habits')) || [];
      } catch (e) {
        console.error('Error parsing habits:', e);
        habits = [];
      }

      try {
        notifications = JSON.parse(localStorage.getItem('notecoco_notifications')) || [];
      } catch (e) {
        console.error('Error parsing notifications:', e);
        notifications = [];
      }

      try {
        trashedNotes = JSON.parse(localStorage.getItem('notecoco_trashedNotes')) || [];
      } catch (e) {
        console.error('Error parsing trashed notes:', e);
        trashedNotes = [];
      }

      // Ensure tags are objects with 'id', 'name', and 'favorite'
      tags = tags.map(tag => {
        if (typeof tag === 'string') {
          return { id: Date.now() + Math.random(), name: tag, favorite: false }; // Assign unique 'id'
        }
        if (!tag.id) {
          tag.id = Date.now() + Math.random(); // Assign unique 'id' if missing
        }
        if (tag.favorite === undefined) tag.favorite = false;
        return tag;
      });

      // Initialize 'favorite' if undefined for other entities
      notebooks.forEach(nb => { if (nb.favorite === undefined) nb.favorite = false; });
      tags.forEach(tag => { if (tag.favorite === undefined) tag.favorite = false; });
      notes.forEach(note => { if (note.favorite === undefined) note.favorite = false; });
      tasks.forEach(task => { if (task.favorite === undefined) task.favorite = false; });
      habits.forEach(habit => { if (habit.favorite === undefined) habit.favorite = false; });
    }

    // Save Data to localStorage
    function saveData() {
      localStorage.setItem('notecoco_notebooks', JSON.stringify(notebooks));
      localStorage.setItem('notecoco_tags', JSON.stringify(tags));
      localStorage.setItem('notecoco_notes', JSON.stringify(notes));
      localStorage.setItem('notecoco_tasks', JSON.stringify(tasks));
      localStorage.setItem('notecoco_habits', JSON.stringify(habits));
      localStorage.setItem('notecoco_notifications', JSON.stringify(notifications)); // Save notifications
      localStorage.setItem('notecoco_trashedNotes', JSON.stringify(trashedNotes)); // Save trashed notes
      
      console.log('Data Saved:', { notebooks, tags, notes, tasks, habits, notifications, trashedNotes });
    }

    // Ensure "Personal" Notebook Exists
    function ensurePersonalNotebook() {
      const personalExists = notebooks.some(nb => nb.name.toLowerCase() === 'personal');
      if (!personalExists) {
        notebooks.push({ id: Date.now(), name: 'Personal', favorite: false });
        saveData();
      }
    }

    // Populate Notebook Selectors
    function populateNotebookSelect() {
      const notebookSelects = document.querySelectorAll('#note-notebook-select, #edit-note-notebook');
      notebookSelects.forEach(select => {
        select.innerHTML = '<option value="">No Notebook</option>';
        notebooks.forEach(nb => {
          const option = document.createElement('option');
          option.value = nb.name;
          option.textContent = nb.name;
          select.appendChild(option);
        });
      });
    }

    // Populate Tag Selectors
    function populateTagSelectors() {
      const tagContainers = document.querySelectorAll('.multi-select, #edit-note-tags');
      tagContainers.forEach(container => {
        container.innerHTML = '';
        tags.forEach(tag => {
          const label = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.value = tag.name;
          label.appendChild(checkbox);
          label.appendChild(document.createTextNode(tag.name));
          container.appendChild(label);
        });
      });
    }

    // Render All Sections
    function renderAll() {
      renderNotebooks();
      renderTags();
      renderNotes();
      renderTasks();
      renderHabits();
      renderDashboardFavorites();
      renderSidebar();
      renderTrash(); // Render Trash section
    }

    // Render Functions for Each Section
    function renderNotebooks() {
      const notebooksList = document.getElementById('notebooks-list');
      notebooksList.innerHTML = '';
      notebooks.forEach(nb => {
        const card = createCard(nb.name, 'notebooks', nb.id, 'book', nb.favorite, () => toggleFavorite('notebooks', nb.id));
        card.id = `notebook-${nb.id}`; // Assign unique ID to the card

        // Add an expand/collapse icon
        const expandIcon = document.createElement('i');
        expandIcon.className = 'fas fa-chevron-right expand-icon';
        card.querySelector('.card-header-left').appendChild(expandIcon);

        // Create a container for nested notes
        const nestedNotesContainer = document.createElement('div');
        nestedNotesContainer.className = 'nested-notes';
        card.appendChild(nestedNotesContainer);

        // Toggle functionality
        card.onclick = (e) => {
          // Prevent triggering on favorite button or action buttons
          if (e.target.closest('.favorite-btn') || e.target.closest('.card-actions')) return;

          const isVisible = nestedNotesContainer.style.display === 'grid';
          nestedNotesContainer.style.display = isVisible ? 'none' : 'grid';
          expandIcon.classList.toggle('expanded', !isVisible);

          if (!isVisible) {
            renderNotesInsideNotebook(nb.id, nestedNotesContainer);
          }
        };

        // Actions for non-Personal notebooks
        if (nb.name.toLowerCase() !== 'personal') {
          const actions = createCardActions([
            { icon: 'edit', title: 'Edit', action: () => openEditModal('notebook', nb.id) },
            { icon: 'trash', title: 'Delete', action: () => deleteNotebook(nb.id) }
          ]);
          card.querySelector('.card-header-right').appendChild(actions);
        }

        card.ondblclick = () => {
          if (nb.name.toLowerCase() !== 'personal') {
            openEditModal('notebook', nb.id);
          } else {
            showNotification('The "Personal" notebook cannot be renamed.', 'error');
          }
        };

        notebooksList.appendChild(card);
      });
    }

    function renderTags() {
      const tagsList = document.getElementById('tags-list');
      tagsList.innerHTML = '';
      tags.forEach(tag => {
        const card = createCard(tag.name, 'tags', tag.id, 'tags', tag.favorite, () => toggleFavorite('tags', tag.id));
        card.id = `tag-${tag.id}`; // Assign unique ID to the card

        const actions = createCardActions([
          { icon: 'edit', title: 'Edit', action: () => openEditModal('tag', tag.id) },
          { icon: 'trash', title: 'Delete', action: () => deleteTag(tag.id) }
        ]);
        card.querySelector('.card-header-right').appendChild(actions);

        card.ondblclick = () => {
          openEditModal('tag', tag.id);
        };

        tagsList.appendChild(card);
      });
    }

    function renderNotes(filteredNotes = null) {
      const notesList = document.getElementById('notes-list');
      notesList.innerHTML = '';
      const notesToRender = filteredNotes || notes;
      notesToRender.forEach(note => {
        const card = createCard(note.title || 'Untitled', 'notes', note.id, 'sticky-note', note.favorite, () => toggleFavorite('notes', note.id));
        card.id = `note-${note.id}`; // Assign unique ID to the card

        const actions = createCardActions([
          { icon: 'edit', title: 'Edit', action: () => openEditModal('note', note.id) },
          { icon: 'trash', title: 'Delete', action: () => deleteNote(note.id) }
        ]);
        card.querySelector('.card-header-right').appendChild(actions);

        // Details
        if (note.body) {
          const snippet = note.body.length > 100 ? note.body.substring(0, 100) + '...' : note.body;
          const body = document.createElement('div');
          body.className = 'details';
          body.textContent = snippet;
          card.appendChild(body);
        }

        if (note.tags.length > 0) {
          const tagDiv = document.createElement('div');
          tagDiv.className = 'details';
          tagDiv.textContent = 'Tags: ' + note.tags.join(', ');
          card.appendChild(tagDiv);
        }

        if (note.notebook) {
          const nbDiv = document.createElement('div');
          nbDiv.className = 'details';
          nbDiv.textContent = 'Notebook: ' + note.notebook;
          card.appendChild(nbDiv);
        }

        if (note.attachments.length > 0) {
          const attachDiv = document.createElement('div');
          attachDiv.className = 'attachments';
          note.attachments.forEach(att => {
            if (att.type.startsWith('image/')) {
              const img = document.createElement('img');
              img.src = att.data;
              img.alt = att.name;
              attachDiv.appendChild(img);
            } else {
              const link = document.createElement('a');
              link.href = att.data;
              link.download = att.name;
              link.textContent = att.name;
              attachDiv.appendChild(link);
            }
          });
          card.appendChild(attachDiv);
        }

        card.ondblclick = () => {
          openEditModal('note', note.id);
        };

        notesList.appendChild(card);
      });
    }

    function renderTasks() {
      const tasksList = document.getElementById('tasks-list');
      tasksList.innerHTML = '';
      tasks.forEach(task => {
        const card = createCard(task.description, 'tasks', task.id, 'tasks', task.favorite, () => toggleFavorite('tasks', task.id));
        card.id = `task-${task.id}`; // Assign unique ID to the card

        const actions = createCardActions([
          { icon: task.completed ? 'undo' : 'check', title: task.completed ? 'Mark as Incomplete' : 'Mark as Complete', action: () => toggleTaskCompletion(task.id) },
          { icon: 'edit', title: 'Edit', action: () => openEditModal('task', task.id) },
          { icon: 'trash', title: 'Delete', action: () => deleteTask(task.id) }
        ]);
        card.querySelector('.card-header-right').appendChild(actions);

        // Details
        if (task.dueDate) {
          const dueDate = document.createElement('div');
          dueDate.className = 'details';
          dueDate.textContent = 'Due: ' + task.dueDate;
          card.appendChild(dueDate);
        }

        if (task.recurrence !== 'none') {
          const recurrence = document.createElement('div');
          recurrence.className = 'details';
          recurrence.textContent = 'Recurs: ' + formatRecurrence(task);
          card.appendChild(recurrence);
        }

        card.ondblclick = () => {
          openEditModal('task', task.id);
        };

        tasksList.appendChild(card);
      });
    }

    function renderHabits() {
      const habitsList = document.getElementById('habits-list');
      habitsList.innerHTML = '';
      habits.forEach(habit => {
        const card = createCard(habit.description, 'habits', habit.id, 'heartbeat', habit.favorite, () => toggleFavorite('habits', habit.id));
        card.id = `habit-${habit.id}`; // Assign unique ID to the card

        const actions = createCardActions([
          { icon: habit.completed ? 'undo' : 'check', title: habit.completed ? 'Mark as Incomplete' : 'Mark as Complete', action: () => toggleHabitCompletion(habit.id) },
          { icon: 'edit', title: 'Edit', action: () => openEditModal('habit', habit.id) },
          { icon: 'trash', title: 'Delete', action: () => deleteHabit(habit.id) }
        ]);
        card.querySelector('.card-header-right').appendChild(actions);

        // Details
        if (habit.recurrence !== 'none') {
          const recurDiv = document.createElement('div');
          recurDiv.className = 'details';
          recurDiv.textContent = 'Recurs: ' + formatRecurrence(habit);
          card.appendChild(recurDiv);
        }

        card.ondblclick = () => {
          openEditModal('habit', habit.id);
        };

        habitsList.appendChild(card);
      });
    }

    // Helper Function to Create Cards
    function createCard(title, type, identifier, icon, favorite, favoriteAction) {
      const card = document.createElement('div');
      card.className = 'card';
      
      const header = document.createElement('div');
      header.className = 'card-header';
      
      const headerLeft = document.createElement('div');
      headerLeft.className = 'card-header-left';
      
      if (icon) {
        const iconElem = document.createElement('i');
        iconElem.className = `fas fa-${icon}`;
        headerLeft.appendChild(iconElem);
      }
      
      const titleSpan = document.createElement('span');
      titleSpan.className = 'title';
      titleSpan.textContent = title;
      headerLeft.appendChild(titleSpan);
      
      header.appendChild(headerLeft);
      
      const headerRight = document.createElement('div');
      headerRight.className = 'card-header-right';
      
      const favoriteBtn = document.createElement('button');
      favoriteBtn.className = 'favorite-btn';
      favoriteBtn.title = favorite ? 'Unfavorite' : 'Favorite';
      favoriteBtn.innerHTML = favorite ? '<i class="fas fa-star"></i>' : '<i class="far fa-star"></i>';
      favoriteBtn.onclick = (e) => {
        e.stopPropagation();
        favoriteAction();
      };
      headerRight.appendChild(favoriteBtn);
      
      // Card actions will be appended by the caller
      header.appendChild(headerRight);
      
      card.appendChild(header);
      
      return card;
    }

    // Helper Function to Create Card Actions
    function createCardActions(actionsArray) {
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'card-actions';
      
      actionsArray.forEach(actionObj => {
        const btn = document.createElement('button');
        btn.title = actionObj.title;
        btn.innerHTML = `<i class="fas fa-${actionObj.icon}"></i>`;
        btn.onclick = (e) => {
          e.stopPropagation();
          actionObj.action();
        };
        actionsDiv.appendChild(btn);
      });
      
      return actionsDiv;
    }

    // Helper Function to Format Recurrence Text
    function formatRecurrence(item) {
      if (item.recurrence === 'daily') return 'Daily';
      if (item.recurrence === 'weekly') return 'Weekly';
      if (item.recurrence === 'monthly') return 'Monthly';
      if (item.recurrence === 'custom') return 'Custom Days (' + item.customDays.join(', ') + ')';
      return 'None';
    }

    // Function to Render Notes Inside a Notebook
    function renderNotesInsideNotebook(notebookId, container) {
      // Clear any existing notes
      container.innerHTML = '';

      // Find the notebook by ID
      const notebook = notebooks.find(nb => nb.id === notebookId);
      if (!notebook) return;

      // Filter notes associated with this notebook
      const associatedNotes = notes.filter(note => note.notebook === notebook.name);

      if (associatedNotes.length === 0) {
        container.innerHTML = '<p style="color: #555; font-size: 0.8rem;">No notes in this notebook.</p>';
        return;
      }

      // Create note cards
      associatedNotes.forEach(note => {
        const noteCard = document.createElement('div');
        noteCard.className = 'nested-note-card';
        noteCard.title = note.title || 'Untitled Note';

        // Note Title
        const noteTitle = document.createElement('div');
        noteTitle.className = 'nested-note-title';
        noteTitle.textContent = note.title || 'Untitled';
        noteCard.appendChild(noteTitle);

        // Note Snippet
        if (note.body) {
          const noteSnippet = document.createElement('div');
          noteSnippet.className = 'nested-note-snippet';
          noteSnippet.textContent = note.body.length > 50 ? note.body.substring(0, 50) + '...' : note.body;
          noteCard.appendChild(noteSnippet);
        }

        // Click event to navigate to the note
        noteCard.onclick = () => {
          navigate('notes', `note-${note.id}`);
          closeSearch(); // Close search modal if open
        };

        container.appendChild(noteCard);
      });
    }

    // Add Notebook (Modified to Include Notification)
    function addNotebook() {
      const input = document.getElementById('new-notebook-input');
      const name = input.value.trim();
      if (!name) {
        showNotification('Notebook name cannot be empty.', 'error');
        return;
      }
      if (notebooks.some(nb => nb.name.toLowerCase() === name.toLowerCase())) {
        showNotification('Notebook with this name already exists.', 'error');
        return;
      }
      notebooks.push({ id: Date.now(), name, favorite: false });
      input.value = '';
      saveData();
      populateNotebookSelect();
      renderNotebooks();
      renderDashboardFavorites();
      showNotification('Notebook added successfully.', 'success');
      addNotification(`New notebook "${name}" created.`);
    }

    // Delete Notebook (Modified to Include Notification)
    function deleteNotebook(id) {
      const notebook = notebooks.find(nb => nb.id === id);
      if (!notebook) return;
      if (notebook.name.toLowerCase() === 'personal') {
        showNotification('The "Personal" notebook cannot be deleted.', 'error');
        return;
      }
      if (confirm(`Are you sure you want to delete the notebook "${notebook.name}"?`)) {
        notebooks = notebooks.filter(nb => nb.id !== id);
        // Unassign notebook from notes
        notes = notes.map(note => {
          if (note.notebook === notebook.name) {
            return { ...note, notebook: '', favorite: note.favorite };
          }
          return note;
        });
        saveData();
        populateNotebookSelect();
        renderNotebooks();
        renderNotes();
        renderDashboardFavorites();
        showNotification('Notebook deleted successfully.', 'success');
        addNotification(`Notebook "${notebook.name}" was deleted.`);
      }
    }

    // Open Edit Modal
    function openEditModal(type, id) {
      switch(type) {
        case 'notebook':
          openEditNotebookModal(id);
          break;
        case 'tag':
          openEditTagModal(id);
          break;
        case 'note':
          openEditNoteModal(id);
          break;
        case 'task':
          openEditTaskModal(id);
          break;
        case 'habit':
          openEditHabitModal(id);
          break;
        default:
          break;
      }
    }

    // Close Edit Modal
    function closeEditModal(type) {
      switch(type) {
        case 'notebook':
          document.getElementById('edit-notebook-modal').style.display = 'none';
          break;
        case 'tag':
          document.getElementById('edit-tag-modal').style.display = 'none';
          break;
        case 'note':
          document.getElementById('edit-note-modal').style.display = 'none';
          break;
        case 'task':
          document.getElementById('edit-task-modal').style.display = 'none';
          break;
        case 'habit':
          document.getElementById('edit-habit-modal').style.display = 'none';
          break;
        default:
          break;
      }
    }

    // Open Edit Notebook Modal
    function openEditNotebookModal(id) {
      const notebook = notebooks.find(nb => nb.id === id);
      if (!notebook) return;
      document.getElementById('edit-notebook-name').value = notebook.name;
      document.getElementById('edit-notebook-form').setAttribute('data-id', id);
      document.getElementById('edit-notebook-modal').style.display = 'block';
    }

    // Handle Edit Notebook Form Submission
    document.getElementById('edit-notebook-form').addEventListener('submit', function(e) {
      e.preventDefault();
      const id = parseInt(this.getAttribute('data-id'));
      const newName = document.getElementById('edit-notebook-name').value.trim();
      if (!newName) {
        showNotification('Notebook name cannot be empty.', 'error');
        return;
      }
      if (notebooks.some(nb => nb.name.toLowerCase() === newName.toLowerCase() && nb.id !== id)) {
        showNotification('Another notebook with this name already exists.', 'error');
        return;
      }
      const notebook = notebooks.find(nb => nb.id === id);
      if (!notebook) return;
      const oldName = notebook.name;
      notebook.name = newName;
      // Update notebook name in notes
      notes = notes.map(note => {
        if (note.notebook === oldName) {
          return { ...note, notebook: newName };
        }
        return note;
      });
      saveData();
      populateNotebookSelect();
      renderNotebooks();
      renderNotes();
      renderDashboardFavorites();
      closeEditModal('notebook');
      showNotification('Notebook updated successfully.', 'success');
      addNotification(`Notebook "${oldName}" was renamed to "${newName}".`);
    });

    // Open Edit Tag Modal
    function openEditTagModal(id) {
      const tag = tags.find(t => t.id === id);
      if (!tag) return;
      document.getElementById('edit-tag-name').value = tag.name;
      document.getElementById('edit-tag-form').setAttribute('data-id', id);
      document.getElementById('edit-tag-modal').style.display = 'block';
    }

    // Handle Edit Tag Form Submission
    document.getElementById('edit-tag-form').addEventListener('submit', function(e) {
      e.preventDefault();
      const id = parseFloat(this.getAttribute('data-id'));
      const newName = document.getElementById('edit-tag-name').value.trim();
      if (!newName) {
        showNotification('Tag name cannot be empty.', 'error');
        return;
      }
      if (tags.some(t => t.name.toLowerCase() === newName.toLowerCase() && t.id !== id)) {
        showNotification('Another tag with this name already exists.', 'error');
        return;
      }
      const tag = tags.find(t => t.id === id);
      if (!tag) return;
      const oldName = tag.name;
      tag.name = newName;
      // Update tag name in notes
      notes = notes.map(note => {
        if (note.tags.includes(tag.name)) {
          return { ...note, tags: note.tags.map(t => t === oldName ? newName : t) };
        }
        return note;
      });
      saveData();
      populateTagSelectors();
      renderTags();
      renderNotes();
      renderDashboardFavorites();
      closeEditModal('tag');
      showNotification('Tag updated successfully.', 'success');
      addNotification(`Tag "${oldName}" was renamed to "${newName}".`);
    });

    // Open Edit Note Modal
    function openEditNoteModal(id) {
      const note = notes.find(n => n.id === id);
      if (!note) return;
      document.getElementById('edit-note-title').value = note.title || '';
      document.getElementById('edit-note-body').value = note.body || '';
      
      // Populate tags
      const editNoteTagsContainer = document.getElementById('edit-note-tags');
      editNoteTagsContainer.innerHTML = '';
      tags.forEach(tag => {
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = tag.name;
        if (note.tags.includes(tag.name)) checkbox.checked = true;
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(tag.name));
        editNoteTagsContainer.appendChild(label);
      });
      document.getElementById('edit-note-new-tags').value = '';
      
      // Populate notebook select
      const editNoteNotebookSelect = document.getElementById('edit-note-notebook');
      editNoteNotebookSelect.innerHTML = '<option value="">No Notebook</option>';
      notebooks.forEach(nb => {
        const option = document.createElement('option');
        option.value = nb.name;
        option.textContent = nb.name;
        if (nb.name === note.notebook) option.selected = true;
        editNoteNotebookSelect.appendChild(option);
      });
      
      // Clear attachments input
      document.getElementById('edit-note-attachments').value = '';
      
      document.getElementById('edit-note-form').setAttribute('data-id', id);
      document.getElementById('edit-note-modal').style.display = 'block';
    }

    // Handle Edit Note Form Submission
    document.getElementById('edit-note-form').addEventListener('submit', function(e) {
      e.preventDefault();
      const id = parseInt(this.getAttribute('data-id'));
      const title = document.getElementById('edit-note-title').value.trim();
      const body = document.getElementById('edit-note-body').value.trim();
      const tagsContainer = document.getElementById('edit-note-tags');
      const newTagsInput = document.getElementById('edit-note-new-tags');
      const notebookSelect = document.getElementById('edit-note-notebook');
      const attachmentsInput = document.getElementById('edit-note-attachments');

      const selectedTags = Array.from(tagsContainer.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
      const newTags = newTagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
      let allNoteTags = [...selectedTags, ...newTags];
      allNoteTags = [...new Set(allNoteTags)]; // Remove duplicates

      // Add new tags to tags list
      newTags.forEach(tag => {
        if (!tags.some(t => t.name.toLowerCase() === tag.toLowerCase())) {
          tags.push({ id: Date.now() + Math.random(), name: tag, favorite: false });
        }
      });

      const notebook = notebookSelect.value;

      const attachments = [];
      const files = attachmentsInput.files;
      const validFileTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'text/plain'];
      
      if (files.length > 0) {
        let filesProcessed = 0;
        for (let file of files) {
          if (file.size > 2 * 1024 * 1024) { // 2MB limit
            showNotification(`File "${file.name}" exceeds the 2MB limit and was not added.`, 'error');
            filesProcessed++;
            if (filesProcessed === files.length) finalizeEditNote();
            continue;
          }
          if (!validFileTypes.includes(file.type)) {
            showNotification(`File type of "${file.name}" is not supported and was not added.`, 'error');
            filesProcessed++;
            if (filesProcessed === files.length) finalizeEditNote();
            continue;
          }
          const reader = new FileReader();
          reader.onload = function(e) {
            attachments.push({
              name: file.name,
              type: file.type,
              data: e.target.result
            });
            filesProcessed++;
            if (filesProcessed === files.length) finalizeEditNote();
          };
          reader.readAsDataURL(file);
        }
      } else {
        finalizeEditNote();
      }

      function finalizeEditNote() {
        const note = notes.find(n => n.id === id);
        if (!note) return;
        note.title = title || 'Untitled';
        note.body = body;
        note.tags = allNoteTags;
        note.notebook = notebook;

        if (attachments.length > 0) {
          note.attachments = note.attachments.concat(attachments);
        }
        saveData();
        populateTagSelectors();
        renderTags();
        renderNotes();
        renderDashboardFavorites();
        closeEditModal('note');
        showNotification('Note updated successfully.', 'success');
        addNotification(`Note "${title || 'Untitled'}" was edited.`);
      }
    });

    // Open Edit Task Modal
    function openEditTaskModal(id) {
      const task = tasks.find(t => t.id === id);
      if (!task) return;
      document.getElementById('edit-task-description').value = task.description;
      document.getElementById('edit-task-due-date').value = task.dueDate || '';
      
      // Set recurrence
      const recurrenceRadios = document.getElementsByName('edit-task-recurrence');
      recurrenceRadios.forEach(radio => {
        if (radio.value === task.recurrence) radio.checked = true;
        else radio.checked = false;
      });
      toggleEditTaskCustomDays(task.recurrence === 'custom');

      // Set custom days
      const editTaskCustomDaysDiv = document.getElementById('edit-task-custom-days');
      editTaskCustomDaysDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        cb.checked = task.customDays.includes(cb.value);
      });

      document.getElementById('edit-task-form').setAttribute('data-id', id);
      document.getElementById('edit-task-modal').style.display = 'block';
    }

    // Toggle Edit Task Custom Days
    function toggleEditTaskCustomDays(show) {
      const customDaysDiv = document.getElementById('edit-task-custom-days');
      if (show) {
        customDaysDiv.style.display = 'flex';
      } else {
        customDaysDiv.style.display = 'none';
        customDaysDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
      }
    }

    // Handle Edit Task Form Submission
    document.getElementById('edit-task-form').addEventListener('submit', function(e) {
      e.preventDefault();
      const id = parseInt(this.getAttribute('data-id'));
      const description = document.getElementById('edit-task-description').value.trim();
      const dueDate = document.getElementById('edit-task-due-date').value;
      const recurrenceRadios = document.getElementsByName('edit-task-recurrence');
      let recurrence = 'none';
      recurrenceRadios.forEach(radio => {
        if (radio.checked) recurrence = radio.value;
      });

      let customDays = [];
      if (recurrence === 'custom') {
        const checkboxes = document.getElementById('edit-task-custom-days').querySelectorAll('input[type="checkbox"]:checked');
        customDays = Array.from(checkboxes).map(cb => cb.value);
        if (customDays.length === 0) {
          showNotification('Please select at least one day for custom recurrence.', 'error');
          return;
        }
      }

      if (!description) {
        showNotification('Task description cannot be empty.', 'error');
        return;
      }

      const task = tasks.find(t => t.id === id);
      if (!task) return;

      const oldDescription = task.description;
      task.description = description;
      task.dueDate = dueDate;
      task.recurrence = recurrence;
      task.customDays = recurrence === 'custom' ? customDays : [];

      saveData();
      renderTasks();
      renderDashboardFavorites();
      closeEditModal('task');
      showNotification('Task updated successfully.', 'success');
      addNotification(`Task "${oldDescription}" was edited.`);
    });

    // Open Edit Habit Modal
    function openEditHabitModal(id) {
      const habit = habits.find(h => h.id === id);
      if (!habit) return;
      document.getElementById('edit-habit-description').value = habit.description;
      
      // Set recurrence
      const recurrenceRadios = document.getElementsByName('edit-habit-recurrence');
      recurrenceRadios.forEach(radio => {
        if (radio.value === habit.recurrence) radio.checked = true;
        else radio.checked = false;
      });
      toggleEditHabitCustomDays(habit.recurrence === 'custom');

      // Set custom days
      const editHabitCustomDaysDiv = document.getElementById('edit-habit-custom-days');
      editHabitCustomDaysDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        cb.checked = habit.customDays.includes(cb.value);
      });

      document.getElementById('edit-habit-form').setAttribute('data-id', id);
      document.getElementById('edit-habit-modal').style.display = 'block';
    }

    // Toggle Edit Habit Custom Days
    function toggleEditHabitCustomDays(show) {
      const customDaysDiv = document.getElementById('edit-habit-custom-days');
      if (show) {
        customDaysDiv.style.display = 'flex';
      } else {
        customDaysDiv.style.display = 'none';
        customDaysDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
      }
    }

    // Handle Edit Habit Form Submission
    document.getElementById('edit-habit-form').addEventListener('submit', function(e) {
      e.preventDefault();
      const id = parseInt(this.getAttribute('data-id'));
      const description = document.getElementById('edit-habit-description').value.trim();
      const recurrenceRadios = document.getElementsByName('edit-habit-recurrence');
      let recurrence = 'none';
      recurrenceRadios.forEach(radio => {
        if (radio.checked) recurrence = radio.value;
      });

      let customDays = [];
      if (recurrence === 'custom') {
        const checkboxes = document.getElementById('edit-habit-custom-days').querySelectorAll('input[type="checkbox"]:checked');
        customDays = Array.from(checkboxes).map(cb => cb.value);
        if (customDays.length === 0) {
          showNotification('Please select at least one day for custom recurrence.', 'error');
          return;
        }
      }

      if (!description) {
        showNotification('Habit description cannot be empty.', 'error');
        return;
      }

      const habit = habits.find(h => h.id === id);
      if (!habit) return;

      const oldDescription = habit.description;
      habit.description = description;
      habit.recurrence = recurrence;
      habit.customDays = recurrence === 'custom' ? customDays : [];

      saveData();
      renderHabits();
      renderDashboardFavorites();
      closeEditModal('habit');
      showNotification('Habit updated successfully.', 'success');
      addNotification(`Habit "${oldDescription}" was edited.`);
    });

    // Add Tag (Modified to Include Notification)
    function addTag() {
      const input = document.getElementById('new-tag-input');
      const name = input.value.trim();
      if (!name) {
        showNotification('Tag name cannot be empty.', 'error');
        return;
      }
      if (tags.some(tag => tag.name.toLowerCase() === name.toLowerCase())) {
        showNotification('Tag already exists.', 'error');
        return;
      }
      tags.push({ id: Date.now() + Math.random(), name, favorite: false }); // Assign unique 'id'
      input.value = '';
      saveData();
      populateTagSelectors();
      renderTags();
      renderDashboardFavorites();
      showNotification('Tag added successfully.', 'success');
      addNotification(`New tag "${name}" created.`);
    }

    // Delete Tag (Modified to Include Notification)
    function deleteTag(id) {
      const tag = tags.find(t => t.id === id);
      if (!tag) return;
      if (confirm(`Are you sure you want to delete the tag "${tag.name}"? This will remove it from all notes.`)) {
        tags = tags.filter(t => t.id !== id);
        // Remove tag from notes
        notes = notes.map(note => {
          if (note.tags.includes(tag.name)) {
            return { ...note, tags: note.tags.filter(t => t !== tag.name) };
          }
          return note;
        });
        saveData();
        populateTagSelectors();
        renderTags();
        renderNotes();
        renderDashboardFavorites();
        showNotification('Tag deleted successfully.', 'success');
        addNotification(`Tag "${tag.name}" was deleted.`);
      }
    }

    // Add Note (Modified to Include Notification)
    function addNote() {
      const titleInput = document.getElementById('note-title');
      const bodyInput = document.getElementById('note-body');
      const tagsContainer = document.getElementById('note-tags');
      const newTagsInput = document.getElementById('note-new-tags');
      const notebookSelect = document.getElementById('note-notebook-select');
      const attachmentsInput = document.getElementById('note-attachments');

      const title = titleInput.value.trim();
      const body = bodyInput.value.trim();
      const selectedTags = Array.from(tagsContainer.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
      const newTags = newTagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
      let allNoteTags = [...selectedTags, ...newTags];
      allNoteTags = [...new Set(allNoteTags)]; // Remove duplicates

      // Add new tags to tags list
      newTags.forEach(tag => {
        if (!tags.some(t => t.name.toLowerCase() === tag.toLowerCase())) {
          tags.push({ id: Date.now() + Math.random(), name: tag, favorite: false });
        }
      });

      const notebook = notebookSelect.value;

      const attachments = [];
      const files = attachmentsInput.files;
      const validFileTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'text/plain'];
      
      if (files.length > 0) {
        let filesProcessed = 0;
        for (let file of files) {
          if (file.size > 2 * 1024 * 1024) { // 2MB limit
            showNotification(`File "${file.name}" exceeds the 2MB limit and was not added.`, 'error');
            filesProcessed++;
            if (filesProcessed === files.length) finalizeAddNote();
            continue;
          }
          if (!validFileTypes.includes(file.type)) {
            showNotification(`File type of "${file.name}" is not supported and was not added.`, 'error');
            filesProcessed++;
            if (filesProcessed === files.length) finalizeAddNote();
            continue;
          }
          const reader = new FileReader();
          reader.onload = function(e) {
            attachments.push({
              name: file.name,
              type: file.type,
              data: e.target.result
            });
            filesProcessed++;
            if (filesProcessed === files.length) finalizeAddNote();
          };
          reader.readAsDataURL(file);
        }
      } else {
        finalizeAddNote();
      }

      function finalizeAddNote() {
        const note = {
          id: Date.now(),
          title,
          body,
          tags: allNoteTags,
          notebook,
          attachments,
          favorite: false
        };
        notes.push(note);
        saveData();
        populateTagSelectors();
        renderTags();
        renderNotes();
        renderDashboardFavorites();
        showNotification('Note added successfully.', 'success');
        addNotification(`New note "${title || 'Untitled'}" created.`);
        clearNoteForm();
      }

      function clearNoteForm() {
        titleInput.value = '';
        bodyInput.value = '';
        newTagsInput.value = '';
        tagsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
        notebookSelect.value = '';
        attachmentsInput.value = '';
      }
    }

    // Delete Note (Modified to Include Trash Functionality and Notification)
    function deleteNote(id) {
      const note = notes.find(n => n.id === id);
      if (!note) return;
      if (confirm('Are you sure you want to delete this note? It will be moved to Trash.')) {
        notes = notes.filter(n => n.id !== id);
        trashedNotes.unshift(note); // Add to trash at beginning
        saveData();
        renderNotes();
        renderDashboardFavorites();
        renderTrash(); // Ensure Trash is updated immediately
        showNotification('Note moved to Trash.', 'success');
        addNotification(`Note "${note.title || 'Untitled'}" was moved to Trash.`);
      }
    }

    // Add Task (Modified to Include Notification)
    function addTask() {
      const descInput = document.getElementById('task-input');
      const dueDateInput = document.getElementById('task-due-date');
      const recurrenceRadios = document.getElementsByName('task-recurrence');
      const customDaysDiv = document.getElementById('task-custom-days');

      const description = descInput.value.trim();
      const dueDate = dueDateInput.value;
      let recurrence = 'none';
      recurrenceRadios.forEach(radio => {
        if (radio.checked) recurrence = radio.value;
      });

      let customDays = [];
      if (recurrence === 'custom') {
        const checkboxes = customDaysDiv.querySelectorAll('input[type="checkbox"]:checked');
        customDays = Array.from(checkboxes).map(cb => cb.value);
        if (customDays.length === 0) {
          showNotification('Please select at least one day for custom recurrence.', 'error');
          return;
        }
      }

      if (!description) {
        showNotification('Task description cannot be empty.', 'error');
        return;
      }

      const task = {
        id: Date.now(),
        description,
        dueDate,
        recurrence,
        customDays,
        completed: false,
        streak: 0,
        lastCompleted: null,
        favorite: false
      };

      tasks.push(task);
      saveData();
      renderTasks();
      renderDashboardFavorites();
      showNotification('Task added successfully.', 'success');
      addNotification(`New task "${description}" created.`);
      clearTaskForm();
    }

    // Clear Task Form
    function clearTaskForm() {
      document.getElementById('task-input').value = '';
      document.getElementById('task-due-date').value = '';
      document.querySelectorAll('input[name="task-recurrence"]').forEach(radio => radio.checked = false);
      document.querySelector('input[name="task-recurrence"][value="none"]').checked = true;
      toggleTaskCustomDays(false);
    }

    // Toggle Task Custom Days
    function toggleTaskCustomDays(show) {
      const customDaysDiv = document.getElementById('task-custom-days');
      if (show) {
        customDaysDiv.style.display = 'flex';
      } else {
        customDaysDiv.style.display = 'none';
        customDaysDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
      }
    }

    // Toggle Task Completion (Modified to Include Notification)
    function toggleTaskCompletion(id) {
      const task = tasks.find(t => t.id === id);
      if (!task) return;
      task.completed = !task.completed;
      if (task.completed) {
        task.lastCompleted = new Date().toDateString();
        task.streak += 1;
        showNotification('Task marked as completed!', 'success');
        addNotification(`Task "${task.description}" was marked as completed.`);
      } else {
        task.lastCompleted = null;
        if (task.streak > 0) task.streak -= 1;
        showNotification('Task marked as incomplete.', 'success');
        addNotification(`Task "${task.description}" was marked as incomplete.`);
      }
      saveData();
      renderTasks();
      renderDashboardFavorites();
    }

    // Delete Task (Modified to Include Notification)
    function deleteTask(id) {
      const task = tasks.find(t => t.id === id);
      if (!task) return;
      if (confirm('Are you sure you want to delete this task?')) {
        tasks = tasks.filter(t => t.id !== id);
        saveData();
        renderTasks();
        renderDashboardFavorites();
        showNotification('Task deleted successfully.', 'success');
        addNotification(`Task "${task.description}" was deleted.`);
      }
    }

    // Add Habit (Modified to Include Notification)
    function addHabit() {
      const descInput = document.getElementById('habit-input');
      const recurrenceRadios = document.getElementsByName('habit-recurrence');
      const customDaysDiv = document.getElementById('habit-custom-days');

      const description = descInput.value.trim();
      if (!description) {
        showNotification('Habit description cannot be empty.', 'error');
        return;
      }

      let recurrence = 'none';
      recurrenceRadios.forEach(radio => {
        if (radio.checked) recurrence = radio.value;
      });

      let customDays = [];
      if (recurrence === 'custom') {
        const checkboxes = customDaysDiv.querySelectorAll('input[type="checkbox"]:checked');
        customDays = Array.from(checkboxes).map(cb => cb.value);
        if (customDays.length === 0) {
          showNotification('Please select at least one day for custom recurrence.', 'error');
          return;
        }
      }

      const habit = {
        id: Date.now(),
        description,
        recurrence,
        customDays,
        completed: false,
        streak: 0,
        lastCompleted: null,
        favorite: false
      };

      habits.push(habit);
      saveData();
      renderHabits();
      renderDashboardFavorites();
      showNotification('Habit added successfully.', 'success');
      addNotification(`New habit "${description}" created.`);
      clearHabitForm();
    }

    // Clear Habit Form
    function clearHabitForm() {
      document.getElementById('habit-input').value = '';
      document.querySelectorAll('input[name="habit-recurrence"]').forEach(radio => radio.checked = false);
      document.querySelector('input[name="habit-recurrence"][value="none"]').checked = true;
      toggleHabitCustomDays(false);
    }

    // Toggle Habit Custom Days
    function toggleHabitCustomDays(show) {
      const customDaysDiv = document.getElementById('habit-custom-days');
      if (show) {
        customDaysDiv.style.display = 'flex';
      } else {
        customDaysDiv.style.display = 'none';
        customDaysDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
      }
    }

    // Toggle Habit Completion (Modified to Include Notification)
    function toggleHabitCompletion(id) {
      const habit = habits.find(h => h.id === id);
      if (!habit) return;
      habit.completed = !habit.completed;
      if (habit.completed) {
        habit.lastCompleted = new Date().toDateString();
        habit.streak += 1;
        showNotification('Habit marked as completed!', 'success');
        addNotification(`Habit "${habit.description}" was marked as completed.`);
      } else {
        habit.lastCompleted = null;
        if (habit.streak > 0) habit.streak -= 1;
        showNotification('Habit marked as incomplete.', 'success');
        addNotification(`Habit "${habit.description}" was marked as incomplete.`);
      }
      saveData();
      renderHabits();
      renderDashboardFavorites();
    }

    // Delete Habit (Modified to Include Notification)
    function deleteHabit(id) {
      const habit = habits.find(h => h.id === id);
      if (!habit) return;
      if (confirm('Are you sure you want to delete this habit?')) {
        habits = habits.filter(h => h.id !== id);
        saveData();
        renderHabits();
        renderDashboardFavorites();
        showNotification('Habit deleted successfully.', 'success');
        addNotification(`Habit "${habit.description}" was deleted.`);
      }
    }

    // Toggle Favorite (Modified to Include Notification)
    function toggleFavorite(type, identifier) {
      switch(type) {
        case 'notebooks':
          const notebook = notebooks.find(nb => nb.id === identifier);
          if (notebook) {
            notebook.favorite = !notebook.favorite;
            if (notebook.favorite) {
              addNotification(`Notebook "${notebook.name}" was added to favorites.`);
            } else {
              addNotification(`Notebook "${notebook.name}" was removed from favorites.`);
            }
          }
          break;
        case 'tags':
          const tag = tags.find(t => t.id === identifier);
          if (tag) {
            tag.favorite = !tag.favorite;
            if (tag.favorite) {
              addNotification(`Tag "${tag.name}" was added to favorites.`);
            } else {
              addNotification(`Tag "${tag.name}" was removed from favorites.`);
            }
          }
          break;
        case 'notes':
          const note = notes.find(n => n.id === identifier);
          if (note) {
            note.favorite = !note.favorite;
            if (note.favorite) {
              addNotification(`Note "${note.title || 'Untitled'}" was added to favorites.`);
            } else {
              addNotification(`Note "${note.title || 'Untitled'}" was removed from favorites.`);
            }
          }
          break;
        case 'tasks':
          const task = tasks.find(t => t.id === identifier);
          if (task) {
            task.favorite = !task.favorite;
            if (task.favorite) {
              addNotification(`Task "${task.description}" was added to favorites.`);
            } else {
              addNotification(`Task "${task.description}" was removed from favorites.`);
            }
          }
          break;
        case 'habits':
          const habit = habits.find(h => h.id === identifier);
          if (habit) {
            habit.favorite = !habit.favorite;
            if (habit.favorite) {
              addNotification(`Habit "${habit.description}" was added to favorites.`);
            } else {
              addNotification(`Habit "${habit.description}" was removed from favorites.`);
            }
          }
          break;
        default:
          break;
      }
      saveData();
      renderAll();
      showNotification('Favorite status updated.', 'success');
    }

    // Render Dashboard Favorites
    function renderDashboardFavorites() {
      renderFavoriteNotebooks();
      renderFavoriteTags();
      renderFavoriteNotes();
      renderFavoriteTasks();
      renderFavoriteHabits();
    }

    function renderFavoriteNotebooks() {
      const favNotebooksList = document.getElementById('favorites-dashboard-notebooks-list');
      favNotebooksList.innerHTML = '';
      const favoriteNotebooks = notebooks.filter(nb => nb.favorite);
      
      if (favoriteNotebooks.length === 0) {
        favNotebooksList.innerHTML = '<p>No favorite notebooks.</p>';
        return;
      }

      favoriteNotebooks.forEach(nb => {
        const card = createCard(nb.name, 'notebooks', nb.id, 'book', nb.favorite, () => toggleFavorite('notebooks', nb.id));
        card.id = `notebook-${nb.id}`; // Assign unique ID to the card

        // Add an expand/collapse icon
        const expandIcon = document.createElement('i');
        expandIcon.className = 'fas fa-chevron-right expand-icon';
        card.querySelector('.card-header-left').appendChild(expandIcon);

        // Create a container for nested notes
        const nestedNotesContainer = document.createElement('div');
        nestedNotesContainer.className = 'nested-notes';
        card.appendChild(nestedNotesContainer);

        // Toggle functionality
        card.onclick = (e) => {
          // Prevent triggering on favorite button or action buttons
          if (e.target.closest('.favorite-btn') || e.target.closest('.card-actions')) return;

          const isVisible = nestedNotesContainer.style.display === 'grid';
          nestedNotesContainer.style.display = isVisible ? 'none' : 'grid';
          expandIcon.classList.toggle('expanded', !isVisible);

          if (!isVisible) {
            renderNotesInsideNotebook(nb.id, nestedNotesContainer);
          }
        };

        // Actions for non-Personal notebooks
        if (nb.name.toLowerCase() !== 'personal') {
          const actions = createCardActions([
            { icon: 'edit', title: 'Edit', action: () => openEditModal('notebook', nb.id) },
            { icon: 'trash', title: 'Delete', action: () => deleteNotebook(nb.id) }
          ]);
          card.querySelector('.card-header-right').appendChild(actions);
        }

        card.ondblclick = () => {
          if (nb.name.toLowerCase() !== 'personal') {
            openEditModal('notebook', nb.id);
          } else {
            showNotification('The "Personal" notebook cannot be renamed.', 'error');
          }
        };

        favNotebooksList.appendChild(card);
      });
    }

    function renderFavoriteTags() {
      const favTagsList = document.getElementById('favorites-dashboard-tags-list');
      favTagsList.innerHTML = '';
      const favoriteTags = tags.filter(tag => tag.favorite);
      
      if (favoriteTags.length === 0) {
        favTagsList.innerHTML = '<p>No favorite tags.</p>';
        return;
      }

      favoriteTags.forEach(tag => {
        const card = createCard(tag.name, 'tags', tag.id, 'tags', tag.favorite, () => toggleFavorite('tags', tag.id));
        card.id = `tag-${tag.id}`; // Assign unique ID to the card

        const actions = createCardActions([
          { icon: 'edit', title: 'Edit', action: () => openEditModal('tag', tag.id) },
          { icon: 'trash', title: 'Delete', action: () => deleteTag(tag.id) }
        ]);
        card.querySelector('.card-header-right').appendChild(actions);

        card.ondblclick = () => {
          openEditModal('tag', tag.id);
        };

        favTagsList.appendChild(card);
      });
    }

    function renderFavoriteNotes() {
      const favNotesList = document.getElementById('favorites-dashboard-notes-list');
      favNotesList.innerHTML = '';
      const favoriteNotes = notes.filter(note => note.favorite);
      
      if (favoriteNotes.length === 0) {
        favNotesList.innerHTML = '<p>No favorite notes.</p>';
        return;
      }

      favoriteNotes.forEach(note => {
        const card = createCard(note.title || 'Untitled', 'notes', note.id, 'sticky-note', note.favorite, () => toggleFavorite('notes', note.id));
        card.id = `note-${note.id}`; // Assign unique ID to the card

        const actions = createCardActions([
          { icon: 'edit', title: 'Edit', action: () => openEditModal('note', note.id) },
          { icon: 'trash', title: 'Delete', action: () => deleteNote(note.id) }
        ]);
        card.querySelector('.card-header-right').appendChild(actions);

        // Details
        if (note.body) {
          const snippet = note.body.length > 100 ? note.body.substring(0, 100) + '...' : note.body;
          const body = document.createElement('div');
          body.className = 'details';
          body.textContent = snippet;
          card.appendChild(body);
        }

        if (note.tags.length > 0) {
          const tagDiv = document.createElement('div');
          tagDiv.className = 'details';
          tagDiv.textContent = 'Tags: ' + note.tags.join(', ');
          card.appendChild(tagDiv);
        }

        if (note.notebook) {
          const nbDiv = document.createElement('div');
          nbDiv.className = 'details';
          nbDiv.textContent = 'Notebook: ' + note.notebook;
          card.appendChild(nbDiv);
        }

        if (note.attachments.length > 0) {
          const attachDiv = document.createElement('div');
          attachDiv.className = 'attachments';
          note.attachments.forEach(att => {
            if (att.type.startsWith('image/')) {
              const img = document.createElement('img');
              img.src = att.data;
              img.alt = att.name;
              attachDiv.appendChild(img);
            } else {
              const link = document.createElement('a');
              link.href = att.data;
              link.download = att.name;
              link.textContent = att.name;
              attachDiv.appendChild(link);
            }
          });
          card.appendChild(attachDiv);
        }

        card.ondblclick = () => {
          openEditModal('note', note.id);
        };

        favNotesList.appendChild(card);
      });
    }

    function renderFavoriteTasks() {
      const favTasksList = document.getElementById('favorites-dashboard-tasks-list');
      favTasksList.innerHTML = '';
      const favoriteTasks = tasks.filter(task => task.favorite);
      
      if (favoriteTasks.length === 0) {
        favTasksList.innerHTML = '<p>No favorite tasks.</p>';
        return;
      }

      favoriteTasks.forEach(task => {
        const card = createCard(task.description, 'tasks', task.id, 'tasks', task.favorite, () => toggleFavorite('tasks', task.id));
        card.id = `task-${task.id}`; // Assign unique ID to the card

        const actions = createCardActions([
          { icon: task.completed ? 'undo' : 'check', title: task.completed ? 'Mark as Incomplete' : 'Mark as Complete', action: () => toggleTaskCompletion(task.id) },
          { icon: 'edit', title: 'Edit', action: () => openEditModal('task', task.id) },
          { icon: 'trash', title: 'Delete', action: () => deleteTask(task.id) }
        ]);
        card.querySelector('.card-header-right').appendChild(actions);

        // Details
        if (task.dueDate) {
          const dueDate = document.createElement('div');
          dueDate.className = 'details';
          dueDate.textContent = 'Due: ' + task.dueDate;
          card.appendChild(dueDate);
        }

        if (task.recurrence !== 'none') {
          const recurrence = document.createElement('div');
          recurrence.className = 'details';
          recurrence.textContent = 'Recurs: ' + formatRecurrence(task);
          card.appendChild(recurrence);
        }

        card.ondblclick = () => {
          openEditModal('task', task.id);
        };

        favTasksList.appendChild(card);
      });
    }

    function renderFavoriteHabits() {
      const favHabitsList = document.getElementById('favorites-dashboard-habits-list');
      favHabitsList.innerHTML = '';
      const favoriteHabits = habits.filter(habit => habit.favorite);
      
      if (favoriteHabits.length === 0) {
        favHabitsList.innerHTML = '<p>No favorite habits.</p>';
        return;
      }

      favoriteHabits.forEach(habit => {
        const card = createCard(habit.description, 'habits', habit.id, 'heartbeat', habit.favorite, () => toggleFavorite('habits', habit.id));
        card.id = `habit-${habit.id}`; // Assign unique ID to the card

        const actions = createCardActions([
          { icon: habit.completed ? 'undo' : 'check', title: habit.completed ? 'Mark as Incomplete' : 'Mark as Complete', action: () => toggleHabitCompletion(habit.id) },
          { icon: 'edit', title: 'Edit', action: () => openEditModal('habit', habit.id) },
          { icon: 'trash', title: 'Delete', action: () => deleteHabit(habit.id) }
        ]);
        card.querySelector('.card-header-right').appendChild(actions);

        // Details
        if (habit.recurrence !== 'none') {
          const recurDiv = document.createElement('div');
          recurDiv.className = 'details';
          recurDiv.textContent = 'Recurs: ' + formatRecurrence(habit);
          card.appendChild(recurDiv);
        }

        card.ondblclick = () => {
          openEditModal('habit', habit.id);
        };

        favHabitsList.appendChild(card);
      });
    }

    // Render Sidebar (Summary)
    function renderSidebar() {
      // Placeholder for additional sidebar summaries if needed
    }

    // Show Notification
    function showNotification(message, type) {
      const notif = document.getElementById('notification');
      notif.textContent = message;
      notif.className = 'notification ' + (type === 'error' ? 'error' : 'success');
      notif.classList.add('show');
      setTimeout(() => {
        notif.classList.remove('show');
      }, 3000);
    }

    // Navigate between sections and optionally scroll to an item
    function navigate(section, itemId = null) {
      const sections = document.querySelectorAll('.kanban-column');
      sections.forEach(sec => {
        if (sec.id === section + '-section') {
          sec.style.display = 'flex';
        } else {
          sec.style.display = 'none';
        }
      });
      const menuItems = document.querySelectorAll('.menu-item');
      menuItems.forEach(item => {
        const span = item.querySelector('span');
        if (span && span.textContent.trim().toLowerCase() === section.toLowerCase()) {
          item.classList.add('active');
        } else {
          item.classList.remove('active');
        }
      });

      // **Call renderTrash() when navigating to 'trash' to ensure it's up-to-date**
      if (section === 'trash') {
        renderTrash();
      }

      if (itemId) {
        setTimeout(() => {
          const element = document.getElementById(itemId);
          if (element) {
            // Calculate the offset position considering the fixed header (60px height)
            const headerOffset = 60;
            const elementPosition = element.getBoundingClientRect().top;
            const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

            window.scrollTo({
              top: offsetPosition,
              behavior: 'smooth'
            });

            // Highlight the element
            element.style.boxShadow = '0 0 10px 2px rgba(100, 100, 255, 0.7)';
            setTimeout(() => {
              element.style.boxShadow = 'none';
            }, 2000);
          }
        }, 500); // Delay to ensure the section is displayed
      }
    }

    // Reset Streaks for Tasks and Habits
    function resetStreaks() {
      const today = new Date();
      const todayStr = today.toLocaleDateString(undefined, { weekday: 'long' });

      tasks.forEach(task => {
        if (task.lastCompleted) {
          const last = new Date(task.lastCompleted);
          const diffTime = today - last;
          const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
          if (shouldResetStreak(task.recurrence, diffDays, last, todayStr)) {
            task.streak = 0;
            task.lastCompleted = null;
            addNotification(`Streak for task "${task.description}" has been reset.`);
          }
        }
      });

      habits.forEach(habit => {
        if (habit.lastCompleted) {
          const last = new Date(habit.lastCompleted);
          const diffTime = today - last;
          const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
          if (shouldResetStreak(habit.recurrence, diffDays, last, todayStr)) {
            habit.streak = 0;
            habit.lastCompleted = null;
            addNotification(`Streak for habit "${habit.description}" has been reset.`);
          }
        }
      });

      saveData();
      renderTasks();
      renderHabits();
      renderDashboardFavorites();
    }

    // Helper Function to Determine If Streak Should Reset
    function shouldResetStreak(recurrence, diffDays, lastDate, todayStr) {
      const today = new Date();
      switch(recurrence) {
        case 'daily':
          return diffDays > 1;
        case 'weekly':
          return diffDays > 7;
        case 'monthly':
          return !isSameMonth(lastDate, today);
        case 'custom':
          // For custom recurrence, check if today is a scheduled day
          return false; // Streak reset logic can be customized as needed
        default:
          return false;
      }
    }

    // Check if two dates are in the same month and year
    function isSameMonth(d1, d2) {
      return d1.getMonth() === d2.getMonth() && d1.getFullYear() === d2.getFullYear();
    }

    // Check Streaks on Load
    resetStreaks();

    // Handle Search

    // Function to Open the Search Modal
    function openSearch() {
      document.getElementById('search-modal').style.display = 'block';
      document.getElementById('search-input').focus(); // Focus on the search input
    }

    // Function to Close the Search Modal
    function closeSearch() {
      document.getElementById('search-modal').style.display = 'none';
      document.getElementById('search-input').value = ''; // Clear search input
      document.getElementById('search-results').innerHTML = ''; // Clear previous results
    }

    // Function to Perform Search
    function performSearch() {
      const query = document.getElementById('search-input').value.trim().toLowerCase();
      const resultsContainer = document.getElementById('search-results');
      resultsContainer.innerHTML = ''; // Clear previous results

      if (query === '') {
        resultsContainer.innerHTML = '<p>Please enter a search term.</p>';
        return;
      }

      // Helper function to highlight search terms
      function highlight(text) {
        const regex = new RegExp(`(${escapeRegExp(query)})`, 'gi');
        return text.replace(regex, '<span class="highlight">$1</span>');
      }

      // Helper function to escape RegExp special characters
      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      }

      // Search Notebooks
      const matchedNotebooks = notebooks.filter(nb => nb.name.toLowerCase().includes(query));
      if (matchedNotebooks.length > 0) {
        const section = document.createElement('div');
        section.className = 'search-category';
        section.innerHTML = `<h4>Notebooks</h4>`;
        matchedNotebooks.forEach(nb => {
          const item = document.createElement('div');
          item.className = 'search-item';
          item.innerHTML = highlight(nb.name);
          item.onclick = () => navigate('notebooks', `notebook-${nb.id}`);
          section.appendChild(item);
        });
        resultsContainer.appendChild(section);
      }

      // Search Tags
      const matchedTags = tags.filter(tag => tag.name.toLowerCase().includes(query));
      if (matchedTags.length > 0) {
        const section = document.createElement('div');
        section.className = 'search-category';
        section.innerHTML = `<h4>Tags</h4>`;
        matchedTags.forEach(tag => {
          const item = document.createElement('div');
          item.className = 'search-item';
          item.innerHTML = highlight(tag.name);
          item.onclick = () => navigate('tags', `tag-${tag.id}`);
          section.appendChild(item);
        });
        resultsContainer.appendChild(section);
      }

      // Search Notes
      const matchedNotes = notes.filter(note => 
        (note.title && note.title.toLowerCase().includes(query)) ||
        (note.body && note.body.toLowerCase().includes(query))
      );
      if (matchedNotes.length > 0) {
        const section = document.createElement('div');
        section.className = 'search-category';
        section.innerHTML = `<h4>Notes</h4>`;
        matchedNotes.forEach(note => {
          const item = document.createElement('div');
          item.className = 'search-item';
          item.innerHTML = highlight(note.title || 'Untitled');
          item.onclick = () => navigate('notes', `note-${note.id}`);
          section.appendChild(item);
        });
        resultsContainer.appendChild(section);
      }

      // Search Tasks
      const matchedTasks = tasks.filter(task => task.description.toLowerCase().includes(query));
      if (matchedTasks.length > 0) {
        const section = document.createElement('div');
        section.className = 'search-category';
        section.innerHTML = `<h4>Tasks</h4>`;
        matchedTasks.forEach(task => {
          const item = document.createElement('div');
          item.className = 'search-item';
          item.innerHTML = highlight(task.description);
          item.onclick = () => navigate('tasks', `task-${task.id}`);
          section.appendChild(item);
        });
        resultsContainer.appendChild(section);
      }

      // Search Habits
      const matchedHabits = habits.filter(habit => habit.description.toLowerCase().includes(query));
      if (matchedHabits.length > 0) {
        const section = document.createElement('div');
        section.className = 'search-category';
        section.innerHTML = `<h4>Habits</h4>`;
        matchedHabits.forEach(habit => {
          const item = document.createElement('div');
          item.className = 'search-item';
          item.innerHTML = highlight(habit.description);
          item.onclick = () => navigate('habits', `habit-${habit.id}`);
          section.appendChild(item);
        });
        resultsContainer.appendChild(section);
      }

      // If no results found
      if (
        matchedNotebooks.length === 0 &&
        matchedTags.length === 0 &&
        matchedNotes.length === 0 &&
        matchedTasks.length === 0 &&
        matchedHabits.length === 0
      ) {
        resultsContainer.innerHTML = '<p>No results found.</p>';
      }
    }

    // Notifications Functions

    // Function to Add a New Notification
    function addNotification(message) {
      const notification = {
        id: Date.now(),
        message: message,
        timestamp: new Date().toLocaleString(),
        read: false
      };
      notifications.unshift(notification); // Add to the beginning
      saveData();
      updateNotificationBadge();
    }

    // Function to Update the Notification Badge Count
    function updateNotificationBadge() {
      const badge = document.getElementById('notification-badge');
      const unreadCount = notifications.filter(notif => !notif.read).length;
      badge.textContent = unreadCount;
      badge.style.display = unreadCount > 0 ? 'inline-block' : 'none';
    }

    // Function to Open Notifications Modal
    function openNotifications() {
      document.getElementById('notifications-modal').style.display = 'block';
      renderNotifications();
    }

    // Function to Close Notifications Modal
    function closeNotifications() {
      document.getElementById('notifications-modal').style.display = 'none';
      renderNotifications(); // Update read status
    }

    // Function to Render Notifications in Modal
    function renderNotifications() {
      const notificationsList = document.getElementById('notifications-list');
      notificationsList.innerHTML = '';

      if (notifications.length === 0) {
        notificationsList.innerHTML = '<p>No notifications.</p>';
        return;
      }

      notifications.forEach(notif => {
        const notifDiv = document.createElement('div');
        notifDiv.className = 'notification-item';
        notifDiv.style.backgroundColor = notif.read ? '#f9f9f9' : '#e0f7fa';

        notifDiv.innerHTML = `
          <p>${notif.message}</p>
          <small>${notif.timestamp}</small>
          <button onclick="markAsRead(${notif.id})">${notif.read ? 'Mark as Unread' : 'Mark as Read'}</button>
        `;

        notificationsList.appendChild(notifDiv);
      });
    }

    // Function to Mark a Notification as Read/Unread
    function markAsRead(id) {
      const notif = notifications.find(n => n.id === id);
      if (notif) {
        notif.read = !notif.read;
        saveData();
        renderNotifications();
        updateNotificationBadge();
      }
    }

    // Initialize Notification Badge on Load
    function initializeNotifications() {
      updateNotificationBadge();
    }

    // Function to Check for Upcoming Events
    function checkUpcomingEvents() {
      const today = new Date();
      const todayStr = today.toLocaleDateString(undefined, { weekday: 'long' });

      // Check for Tasks nearing due dates (e.g., within 2 days)
      tasks.forEach(task => {
        if (task.dueDate && !task.completed) {
          const dueDate = new Date(task.dueDate);
          const diffTime = dueDate - today;
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
          if (diffDays >= 0 && diffDays <= 2) {
            addNotification(`Task "${task.description}" is due on ${task.dueDate}.`);
          }
        }
      });

      // Check for Habits scheduled today
      habits.forEach(habit => {
        if (habit.recurrence === 'daily') {
          addNotification(`Habit "${habit.description}" is scheduled for today.`);
        } else if (habit.recurrence === 'custom' && habit.customDays.includes(todayStr)) {
          addNotification(`Habit "${habit.description}" is scheduled for today.`);
        }
        // Add more conditions for other recurrence types if needed
      });
    }

    // Render Trash Section
    function renderTrash() {
      const trashList = document.getElementById('trash-list');
      trashList.innerHTML = '';

      if (trashedNotes.length === 0) {
        // **Added: Display a message when Trash is empty**
        const emptyMessage = document.createElement('p');
        emptyMessage.textContent = 'Trash is empty.';
        emptyMessage.style.color = '#555';
        emptyMessage.style.fontSize = '0.9rem';
        trashList.appendChild(emptyMessage);
        return;
      }

      trashedNotes.forEach(note => {
        const card = createCard(note.title || 'Untitled', 'notes', note.id, 'sticky-note', note.favorite, () => toggleFavorite('notes', note.id));
        card.id = `trash-note-${note.id}`; // Assign unique ID to the card

        const actions = createCardActions([
          { icon: 'undo', title: 'Restore', action: () => restoreNote(note.id) },
          { icon: 'trash', title: 'Delete Permanently', action: () => permanentlyDeleteNote(note.id) }
        ]);
        card.querySelector('.card-header-right').appendChild(actions);

        // Details
        if (note.body) {
          const snippet = note.body.length > 100 ? note.body.substring(0, 100) + '...' : note.body;
          const body = document.createElement('div');
          body.className = 'details';
          body.textContent = snippet;
          card.appendChild(body);
        }

        if (note.tags.length > 0) {
          const tagDiv = document.createElement('div');
          tagDiv.className = 'details';
          tagDiv.textContent = 'Tags: ' + note.tags.join(', ');
          card.appendChild(tagDiv);
        }

        if (note.notebook) {
          const nbDiv = document.createElement('div');
          nbDiv.className = 'details';
          nbDiv.textContent = 'Notebook: ' + note.notebook;
          card.appendChild(nbDiv);
        }

        if (note.attachments.length > 0) {
          const attachDiv = document.createElement('div');
          attachDiv.className = 'attachments';
          note.attachments.forEach(att => {
            if (att.type.startsWith('image/')) {
              const img = document.createElement('img');
              img.src = att.data;
              img.alt = att.name;
              attachDiv.appendChild(img);
            } else {
              const link = document.createElement('a');
              link.href = att.data;
              link.download = att.name;
              link.textContent = att.name;
              attachDiv.appendChild(link);
            }
          });
          card.appendChild(attachDiv);
        }

        card.ondblclick = () => {
          restoreNote(note.id);
        };

        trashList.appendChild(card);
      });
    }

    // Function to Restore a Note from Trash
    function restoreNote(id) {
      const noteIndex = trashedNotes.findIndex(n => n.id === id);
      if (noteIndex === -1) return;
      const note = trashedNotes.splice(noteIndex, 1)[0];
      notes.push(note);
      saveData();
      renderTrash();
      renderNotes();
      renderDashboardFavorites();
      showNotification('Note restored successfully.', 'success');
      addNotification(`Note "${note.title || 'Untitled'}" was restored from Trash.`);
    }

    // Function to Permanently Delete a Note from Trash
    function permanentlyDeleteNote(id) {
      const noteIndex = trashedNotes.findIndex(n => n.id === id);
      if (noteIndex === -1) return;
      const note = trashedNotes[noteIndex];
      if (confirm(`Are you sure you want to permanently delete the note "${note.title || 'Untitled'}"? This action cannot be undone.`)) {
        trashedNotes.splice(noteIndex, 1);
        saveData();
        renderTrash();
        renderDashboardFavorites();
        showNotification('Note permanently deleted.', 'success');
        addNotification(`Note "${note.title || 'Untitled'}" was permanently deleted.`);
      }
    }

    // Function to Add a New Notification
    // (Already implemented above as addNotification)

    // Function to Update the Notification Badge Count
    // (Already implemented above as updateNotificationBadge)

    // Function to Open Notifications Modal
    // (Already implemented above as openNotifications)

    // Function to Close Notifications Modal
    // (Already implemented above as closeNotifications)

    // Function to Render Notifications in Modal
    // (Already implemented above as renderNotifications)

    // Function to Mark a Notification as Read/Unread
    // (Already implemented above as markAsRead)

    // Initialize Notification Badge on Load
    // (Already implemented above as initializeNotifications)

    // Function to Check for Upcoming Events
    // (Already implemented above as checkUpcomingEvents)

    // Close the modal when clicking outside of it
    window.onclick = function(event) {
      const searchModal = document.getElementById('search-modal');
      if (event.target == searchModal) {
        searchModal.style.display = 'none';
        document.getElementById('search-input').value = '';
        document.getElementById('search-results').innerHTML = '';
      }

      const notificationsModal = document.getElementById('notifications-modal');
      if (event.target == notificationsModal) {
        notificationsModal.style.display = 'none';
        renderNotifications();
      }

      const editNotebookModal = document.getElementById('edit-notebook-modal');
      if (event.target == editNotebookModal) {
        editNotebookModal.style.display = 'none';
      }

      const editTagModal = document.getElementById('edit-tag-modal');
      if (event.target == editTagModal) {
        editTagModal.style.display = 'none';
      }

      const editNoteModal = document.getElementById('edit-note-modal');
      if (event.target == editNoteModal) {
        editNoteModal.style.display = 'none';
      }

      const editTaskModal = document.getElementById('edit-task-modal');
      if (event.target == editTaskModal) {
        editTaskModal.style.display = 'none';
      }

      const editHabitModal = document.getElementById('edit-habit-modal');
      if (event.target == editHabitModal) {
        editHabitModal.style.display = 'none';
      }
    };
    
  </script>
</body>
</html>
